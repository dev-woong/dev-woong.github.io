[{"content":"https://www.acmicpc.net/problem/1032\n입력된 동일한 길이의 문자열에서 문자가 다른 인덱스의 값을 \u0026lsquo;?\u0026lsquo;로 변경하여 출력하는 문제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 개수 입력 var input_count = Console.ReadLine(); // input_count 개수만큼 추가로 입력(CharArray 형태로 Return) var input_list = Enumerable.Range(0, Convert.ToInt32(input_count)).Select(_ =\u0026gt; Console.ReadLine()?.ToCharArray()).ToList(); // 0번 인덱스의 값을 기준값으로 지정 var result = input_list[0]; // 입력받은 값의 리스트를 순환하여 반복 foreach (var check_string in input_list) // 입력받은 문자열 각각을 비교하기 위해 Length 값 만큼 반복 for (var j = 0; j \u0026lt; result!.Length; j++) { // 문자열의 각 문자가 같으면 반복을 이어나간다. if (result[j] == check_string![j]) continue; // 문자열의 각 문자가 틀리면 해당 문자를 \u0026#39;?\u0026#39;로 치환한다. result[j] = \u0026#39;?\u0026#39;; } Console.WriteLine(result); ","date":"2022-08-21T00:00:00Z","permalink":"https://dev-woong.io/p/baekjoon-1032-%EB%AA%85%EB%A0%B9-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8/","title":"[BAEKJOON] 1032 - 명령 프롬프트"},{"content":"https://www.acmicpc.net/problem/10828\n스택 및 스택 명령어를 구현하여 데이터를 입/출력하는 문제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 명령어의 개수 입력 var command_count = int.Parse(Console.ReadLine()!); // Stack으로 사용될 변수 생성 var stack = new List\u0026lt;int\u0026gt;(); // 명령어 개수 만큼 반복 while (command_count-- \u0026gt; 0) { // 명령어 입력 후 공백(\u0026#34; \u0026#34;)을 기준으로 분리 var command = Console.ReadLine()!.Split(\u0026#34; \u0026#34;); // 공백 기준 앞에 있는 명령어를 통한 switch 조건 분기 switch (command[0]) { case \u0026#34;push\u0026#34;: // stack 변수에 데이터 축적 stack.Add(int.Parse(command[1])); continue; case \u0026#34;pop\u0026#34;: // Stack의 특성에 따라 후입선출하여 마지막 데이터부터 pop! // Any() 함수는 조건에 맞는 값이 해당 컬렉션에 존재하는지 확인하는 함수이다. // 매개변수가 없는 경우는 컬렉션에 값이 존재하는지 여부를 반환한다. Console.WriteLine(stack.Any() ? stack.Last().ToString() : \u0026#34;-1\u0026#34;); if (stack.Any()) stack.RemoveAt(stack.Count - 1); continue; case \u0026#34;size\u0026#34;: Console.WriteLine(stack.Count.ToString()); continue; case \u0026#34;empty\u0026#34;: Console.WriteLine(stack.Any() ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;); continue; case \u0026#34;top\u0026#34;: // Linq의 Last()를 이용하여 마지막 값을 반환받는다. Console.WriteLine(stack.Any() ? stack.Last().ToString() : \u0026#34;-1\u0026#34;); continue; } } ","date":"2022-08-21T00:00:00Z","permalink":"https://dev-woong.io/p/baekjoon-10828-%EC%8A%A4%ED%83%9D/","title":"[BAEKJOON] 10828 - 스택"},{"content":"https://www.acmicpc.net/problem/10845\n스택 및 스택 명령어를 구현하여 데이터를 입/출력하는 문제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 명령어의 개수 입력 var command_count = int.Parse(Console.ReadLine()!); // Queue로 사용될 변수 생성 var queue = new List\u0026lt;int\u0026gt;(); // 명령어 개수 만큼 반복 while (command_count-- \u0026gt; 0) { // 명령어 입력 후 공백(\u0026#34; \u0026#34;)을 기준으로 분리 var command = Console.ReadLine()!.Split(\u0026#34; \u0026#34;); // 공백 기준 앞에 있는 명령어를 통한 switch 조건 분기 switch (command[0]) { case \u0026#34;push\u0026#34;: // queue 변수에 데이터 축적 queue.Add(int.Parse(command[1])); continue; case \u0026#34;pop\u0026#34;: // Queue의 특성에 따라 선입선출하여 처음 데이터부터 pop! // Any() 함수는 조건에 맞는 값이 해당 컬렉션에 존재하는지 확인하는 함수이다. // 매개변수가 없는 경우는 컬렉션에 값이 존재하는지 여부를 반환한다. Console.WriteLine(queue.Any() ? queue.First().ToString() : \u0026#34;-1\u0026#34;); if (queue.Any()) queue.RemoveAt(0); continue; case \u0026#34;size\u0026#34;: Console.WriteLine(queue.Count.ToString()); continue; case \u0026#34;empty\u0026#34;: Console.WriteLine(queue.Any() ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;); continue; case \u0026#34;front\u0026#34;: // Linq의 First()를 이용하여 첫 번째 값을 반환받는다. Console.WriteLine(queue.Any() ? queue.First().ToString() : \u0026#34;-1\u0026#34;); continue; case \u0026#34;back\u0026#34;: // Linq의 Last()를 이용하여 마지막 값을 반환받는다. Console.WriteLine(queue.Any() ? queue.Last().ToString() : \u0026#34;-1\u0026#34;); continue; } } ","date":"2022-08-21T00:00:00Z","permalink":"https://dev-woong.io/p/baekjoon-10845-%ED%81%90/","title":"[BAEKJOON] 10845 - 큐"},{"content":"https://www.acmicpc.net/problem/10872\n입력받은 정수만큼 팩토리얼 연산을 수행하는 문제\n1 2 3 4 5 6 7 8 9 10 // 팩토리얼 개수 입력 var count = Convert.ToInt32(Console.ReadLine()); // Enumerable.Range()를 통해 1부터 {count}개의 차례대로 증가되는 컬렉션을 생성 // 해당 컬렉션의 값을 Linq의 Aggregate 함수를 통해 집계 // 컬렉션에 데이터가 없는 경우 1을 sum에 저장, 데이터가 있는 경우 i에 차례대로 할당되어 연산 수행 // 연산의 결과값이 current에 누적되어 최종 결과값이 sum에 저장됨 var sum = Enumerable.Range(1, count).Aggregate(1, (current, i) =\u0026gt; current * i); Console.WriteLine(sum); ","date":"2022-08-21T00:00:00Z","permalink":"https://dev-woong.io/p/baekjoon-10872-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC/","title":"[BAEKJOON] 10872 - 팩토리얼"},{"content":"https://www.acmicpc.net/problem/1550\n입력받은 16진수 문자열을 10진수로 출력해주는 문제.\nC#에서의 진수 변환에 대해 알아보는 개념으로 풀어보았습니다.\n1 2 3 4 5 6 7 8 // 입력 var input = Console.ReadLine(); // 16진수 변환 var hex = Convert.ToInt32(input, 16); // 출력 Console.WriteLine(hex); ","date":"2022-08-21T00:00:00Z","permalink":"https://dev-woong.io/p/baekjoon-1550-16%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98/","title":"[BAEKJOON] 1550 - 16진수 변환"},{"content":"고박사의 유니티 노트 [Unity 2D Basic] 06-01. 2D Tilemap Editor\nTilemap Editor Tilemap Palette Tilemap 오브젝트에 배치할 때는 Tile Asset들을 등록해두는 저장소 팔레트에 있는 Tile Asset을 여러 속성에 따라 배치하거나 삭제할 수 있음 Grid 오브젝트 자식으로 배치되는 Tilemap 오브젝트들을 관리하는 역할 Cell Layout, Cell Swizzle 정보를 이용해 배치되는 맵의 방식을 Rectangle, Hexagon, Isometric, Isometric Z As Y 등으로 설정할 수 있음 Tilemap 오브젝트 Tile Asset을 배치하는 공간으로 실제 게임에 보여지는 타일 형태의 월드 Grid 오브젝트의 자식으로 여러 개의 Tilemap 오브젝트 등록 가능 (Layer 구분) 강의와 현재의 편차가 있는 듯 한데, 해당 차이점 등에 대해 이해 후 다시 포스팅 하겠습니다.\n","date":"2022-08-17T00:00:00Z","image":"https://dev-woong.io/p/til-tilemap-%EA%B8%B0%EC%B4%88/title_hu0c7b1c0f323ae47fcc128dfa9d76da97_315993_120x120_fill_q75_box_smart1.jpg","permalink":"https://dev-woong.io/p/til-tilemap-%EA%B8%B0%EC%B4%88/","title":"[TIL] Tilemap 기초"},{"content":"고박사의 유니티 노트 [Unity 2D Basic] 05-01. 2D Sprite / Animation\nDraw Call \u0026amp; Batches Draw Call CPU가 GPU에게 Draw 요청하는 것 이 값이 낮을수록 앱이 가벼우며 기기에 따라 특정 개수 이상 시 프레임 드랍 발생 모바일의 경우 100개를 넘기지 않는 것을 권장 (요즘 기종은 120Hz를 지원) Batches Draw Call 을 포함하는 상위 개념 Unity 5.0부터 Draw Call 대신 Batches를 기준으로 Stats에 렌더링 정보를 표시함 Batches는 Mesh, Material, Shader, Draw Call 등의 정보를 종합적으로 계산함 Sprite Atlas 여러 이미지 파일을 한 장의 텍스처에 모아 두고 사용하는 것 Unity는 Sprite Packer(Legacy)와 Sprite Atlas를 제공합니다 Sprite Atlas를 사용해야 하는 이유 2D 게임에서 배경이나 캐릭터, 적 등을 표현하는데 사용되는 이미지 에셋은 매번 렌더링 할 때마다 각 이미지 에셋 별로 1의 Batches 증가 예를 들어 게임에 사용되는 캐릭터, 적, 아이템 모두 다른 이미지를 사용하는 Object가 100개 있고, 동시에 게임에 등장한다면 Batches 값은 100 반대로 동일한 이미지를 사용하는 오브젝트가 100개 일 때는 Batches 값은 1 Sprite Atlas를 이용해 서로 다른 이미지를 하나의 텍스처에 모아 두고 사용하면 서로 다른 이미지의 오브젝트를 100개 만든다고 해도 Batches 값은 1 Sprite Atlas 사용 시 주의 사항 모든 이미지 에셋을 하나의 Sprite Atlas로 묶게 되면 내부의 이미지 하나만 사용해도 해당 Sprite Atlas의 모든 이미지 정보를 불러옴 한 화면에 함께 사용되는 것 또는 하나의 오브젝트에서 함께 사용되는 것 처럼 관련이 있는 이미지들을 하나의 Sprite Atlas로 묶어주는 것이 좋음 Texture Asset 이미지 분할과 POT(Power of Two) 규격 하나의 이미지 에셋에 여러 장의 그림을 그리고 분할하여 사용하는 이유 게임에서 사용되는 텍스처를 제작할 때에는 POT 규격으로 제작해야 함 POT(Power of Two) : 텍스처의 가로/세로 사이즈가 2의 제곱 POT 규격이 아닌 텍스처는 POT 규격으로 변환하기 위해 내부적인 처리를 거치게 되고 이로 인한 메모리 비용 증가 보통 게임에 사용되는 이미지는 POT 규격으로 제작될 수 없기 때문에 하나의 POT 규격 텍스처에 여러 장의 이미지(유사한 성격을 가진 이미지)를 넣어서 제작한다. Animation Animation Asset 하나의 애니메이션 동작을 저장하는 파일(걷기, 뛰기, 공격 등) 2D Sprite Animation Animator Component Animator Controller Asset Animation Asset Animator Controller Asset 하나의 오브젝트가 가질 수 있는 애니메이션을 묶어서 관리하는 파일 Animator Component 게임 오브젝트의 애니메이션 재생, 교체 등을 제어하는 역할 수행 ","date":"2022-08-16T00:00:00Z","image":"https://dev-woong.io/p/til-sprite-animation-%EA%B8%B0%EC%B4%88/title_hu0096dda4e273fbf89356e52b3c320932_1312605_120x120_fill_q75_box_smart1.jpg","permalink":"https://dev-woong.io/p/til-sprite-animation-%EA%B8%B0%EC%B4%88/","title":"[TIL] Sprite, Animation 기초"},{"content":"Github Apps 란? Github에서 동작하는 GitHub API와 통합되는 프로젝트에서 GitHub 데이터에 접근하기 위한 세분화된 권한을 제공하기 때문에 GitHub에서 공식적으로 권장하는 Application 등록 방법입니다.\nGitHub App은 API를 통해 직접 작업을 수행하므로 별도의 봇 또는 서비스 계정이 필요하지 않습니다.\nGitHub App과 OAuth App의 차이점\nGithub Apps 생성하기 GitHub 로그인 GitHub Login 페이지에서 로그인합니다.\n설정 페이지 이동 GitHub 홈 화면에서 우측 상단 사용자 아이콘을 클릭 후 하단의 Setting를 클릭하면 설정 페이지로 이동됩니다.\n이동 후, 좌측 메뉴 최하단의 Developer settings 를 클릭합니다.\nDeveloper Setting 화면에서 좌측의 GitHub Apps를 클릭하고 New GitHub App을 클릭합니다. Password 또는 2-Factor 인증, 또는 휴대폰 앱을 통한 인증을 진행하면 GitHub Apps 설정 화면으로 이동합니다.\n세부 설정 * 표시가 붙어있는 항목은 필수 입력 항목입니다.\nRegister new GitHub App GitHub App Name : 생성할 GitHub App 이름 (기존 GitHub 계정과 동일한 이름 불가) This is displayed to users of your GitHub App : GitHub App에 대한 설명(마크다운 형식 지원) Homepage URL : 앱 웹사이트의 전체 URL 특별히 해당 앱을 사용하는 사이트가 없는 경우 https://127.0.0.1 (루프백)등으로 입력 Identifying and authorizing users Callback URL : 사용자가 해당 앱을 승인한 후 리디렉션 될 URL 이 URL은 앱이 사용자-서버 요청을 식별/승인해야 하는 경우 사용 Add Callback URL 을 통해 최대 10개의 추가 Callback URL을 사용 가능 Expire user authorization : 액세스 토큰에 대한 만료 설정 해당 옵션 선택 시 액세스 토큰이 만료될 때 업데이트된 토큰을 요청할 수 있는 refresh_token 제공 GitHub Docs - 사용자-서버 액세스 토큰 새로 고침 Request user ahtorization (OAuth) during installation : GitHub App에 사용자 권한 부여(OAuth) 해당 옵션 활성화 시 Callback URL이 필수 입력 항목으로 전환되고, 아래 Post Installation의 Setup URL은 비활성화됨 GitHub App 생성 후 Callback URL 로 리디렉션 되면 Callback Code 를 Get 파라미터로 전달받게 되고 이것으로 액세스 토큰을 발급 후 API에 액세스 GitHub Docs - Authorizing users during installation Enable Device Flow : CLI 도구 또는 Git 자격 증명 관리자와 같은 헤드리스 앱 권한 부여 GitHub Docs - Device Flow Post installation Setup URL : 추가 설정이 필요한 경우 GitHub App 구성 후 원하는 URL으로 리디렉션 상단 Identifying and authorizing users 에서 Request user ahtorization (OAuth) during installation 체크 시 비활성화 Redirect on update : GitHub App이 업데이트된 후 사용자를 Setup URL 로 리디렉션 (예: 리포지터리 추가/제거) Webhook Active : 웹훅 활성화 설정 Webhook URL : App에서 이벤트가 발생하는 경우 데이터를 받을 URL Webhook Secret : 원하는 사용자만 hook 을 받을 수 있도록 설정하는 선택적 보안 토큰 Repository permissions Permission(권한)은 총 3가지 상태로 지정할 수 있다.\nNo Access : 허용하지 않음 Read-only : 읽기만 허용 Read and Write : 읽기/쓰기 허용 Actions : GitHub의 CI/CD 플랫폼인 GitHub Actions 관련 권한 Administration : 리포지토리 생성, 삭제, 설정, 팀 및 Collaborators 관련 권한 Checks : 코드 검사 관련 권한 Code scanning alerts : 리포지토리의 보안 탭에 있는 코드 취약점 스캔 경고 관련 권한 Codespaces : GitHub 내장 IDE인 Codespace 생성, 편집, 삭제 등 관련 권한 Codespaces lifecycle admin : 특정 사용자에 대한 Codespace 시작/중지 등 lifecycle 관련 권한 Codespaces metadata : container 및 machine 등에 대한 Codespace 메타데이터 관련 권한 Codespaces secrets : Codespace에서 액세스할 수 있는 리포지토리에 대한 비밀 관련 권한 Commit statuses : 커밋 상태 관련 권한 Contents : 리포지토리, 커밋, 브랜치, 다운로드, 릴리즈 및 병합 관련 권한 Dependabot alerts : GitHub 종속성 관리 기능인 Dependabot의 경고 관련 권한 Dependabot secrets : Dependabot의 리포지토리 비밀 관련 권한 Deployments : 배포 및 배포 상태 관련 권한 Discussions : 토론 및 의견, 레이블 관련 권한 Environments : 리포지토리 환경 변수 관련 권한 Issues : 이슈 관련 권한 Merge queues 리포지토리의 병합 대기열 관리 권한 Metadata : 리포지터리 검색, Collaborators 나열, 리포지토리 메타데이터 관련 권한 Packages : GitHub 패키지 플랫폼 관련 권한 Pages : 정적 웹 호스팅 서비스 Github Pages 관련 권한 Projects : Github Projects 기능의 열 및 카드 관련 권한 Pull requests : Pull Request 기능 관련 권한 Secret scanning alerts : 비밀 스캔 알림 관련 권한 Secrets : 리포지토리 비밀 관련 권한 Single file : 하나의 파일만 관리하는 권한(..??) Webhooks : 웹훅 관련 권한 Workflows : GitHub Actions Workflow 파일 업데이트 관련 권한 Organization permissions Administration : 조직에 대한 액세스 관리 권한 Blocking users : 사용자 차단 관련 권한 Events : 조직의 트리거된(?) 이벤트 관련 권한 Members : 조직 구성원 및 팀 관련 권한 Organization codespaces : 조직의 Codespaces 관련 권한 Organization codespaces secrets : 조직의 Codespaces 비밀 관련 권한 Organization dependabot secrets : 조직의 Dependabot 비밀 관련 권한 Plan : 조직의 Plan(라이센스) 관련 권한 Projects : 조직 프로젝트 관련 권한 Secrets : 조직의 Actions 비밀 관리 권한 Self-hosted runners : 조직에서 사용할 수 있는 Actions 자체 호스팅 실행자 관련 권한 Team discussions : 팀 토론 및 관련 의견 관리 권한 Webhooks : 조직의 웹훅 관련 권한 User permissions Block another user : 사용자 차단 관련 권한 Codespaces user secrets : Codespace 비밀 관련 권한 Email addresses : 사용자의 이메일 주소 관련 권한 Followers : 사용자의 팔로워 관련 권한 GPG keys : 사용자의 GPG 키 관리 권한 Gists : 사용자의 GitHub Gists(코드, 메모, 로그 등 공유 기능) 관련 권한 Git SSH keys : Git을 통해 접근할 때에 사용되는 SSH 키 관련 권한 Interaction limits : 리포지토리 상호 작용 제한 권한 Plan : 사용자의 Plan(라이센스) 관련 권한 Profile : 사용자의 프로필 설정 관련 권한 Starring : 사용자가 Starring한 리포지토리 관련 권한 Watching : 사용자가 Watching하는 저장소 관련 권한 Subscribe to events 선택한 권한에 대해 구독할 이벤트를 선택합니다.\nMeta : 이 앱이 삭제되고 연결된 후크가 제거되는 경우 Security Advisory : 보안 권고가 게시, 업데이트 또는 철회되는 경우 생성 완료 최초 생성 이후에는 상단에 노란 바탕으로 경고 메시지가 발생하게 되는데 생성한 GitHub App에 Private Key가 없기 때문에 발생하는 문제입니다.\n하단의 Private keys 에서 Generate a private key 를 클릭해 Private Key를 하나 생성해주면 앱 사용 준비가 완료됩니다. (필자의 경우 하나의 Private key가 생성되어있는 상태)\n마무리 생성한 GitHub App을 이용하면 GitKraken, Gitter 등의 써드파티 앱 처럼 GitHub와 통합되는 앱을 생성할 수 있는 것으로 보입니다.\n해당 문서는 공식 문서의 비공식 번역본 정도로 참고해주시면 감사하겠으며 추가적으로 해당 앱을 활용하며 이해도가 높아지게 된다면 세부적인 내용들에 대해서 다시 다루어보겠습니다.\n참고 자료 : https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps\n","date":"2022-08-14T00:00:00Z","image":"https://dev-woong.io/p/github-apps-%EC%84%B8%EB%B6%80-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%83%9D%EC%84%B1/github_huae23cbee81be171be328d6e4b7bf84c2_2153626_120x120_fill_q75_box_smart1.jpg","permalink":"https://dev-woong.io/p/github-apps-%EC%84%B8%EB%B6%80-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%83%9D%EC%84%B1/","title":"Github Apps 세부 설정 및 생성"},{"content":"Access Token 이란? GitHub에서는 HTTPS 에서의 ID/Password 인증 방식을 금지하고 Access Token 인증 방식으로 전환되었습니다.\nPersonal Access Token은 HTTPS 인증 시 Git의 암호 대신 사용하거나 API를 인증하는 데 사용할 수 있는 값 입니다.\nPersonal Access Token 생성 GitHub 로그인 GitHub Login 페이지에서 로그인합니다.\n설정 페이지 이동 GitHub 홈 화면에서 우측 상단 사용자 아이콘을 클릭 후 하단의 Setting를 클릭하면 설정 페이지로 이동됩니다.\n이동 후, 좌측 메뉴 최하단의 Developer settings 를 클릭합니다.\nDeveloper Setting 화면에서 좌측의 Personal access tokens를 클릭하고 Generate new token을 클릭합니다.\n(작성자는 기존에 생성한 토큰이 한 개 있는 상태이므로 표시되는 화면이 다를 수 있습니다.)\n토큰 이름 : 자유롭게 작성 만료 기간 : 자유롭게 선택하거나, 만료되지 않도록 설정 토큰 권한 : git 로그인 또는 API 사용 시에 필요한 만큼의 권한 할당 Token 생성 완료 이제 생성한 토큰으로 HTTPS Url을 이용한 Clone 요청이나, GitHub의 여러 API(RestFul, GraphQL)등을 이용할 수 있습니다.\n","date":"2022-08-09T00:00:00Z","image":"https://dev-woong.io/p/github-personal-access-token-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/github_hu05bbc713fbac683e943f7daf5a88f075_1208353_120x120_fill_q75_box_smart1.jpg","permalink":"https://dev-woong.io/p/github-personal-access-token-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/","title":"GitHub Personal Access Token 생성하기"}]